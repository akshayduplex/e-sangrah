<%- include('../../partials/header') %>

	<style>
		/* Folder container using flexbox for 5 folders per row */
		#folder-container {
			display: flex;
			flex-wrap: wrap;
			gap: 15px;
			/* spacing between folders */
		}

		.folderbox {
			flex: 0 0 calc(20% - 15px);
			/* 20% width for 5 per row minus gap */
			box-sizing: border-box;
		}

		/* Responsive adjustments */
		@media (max-width: 1200px) {
			.folderbox {
				flex: 0 0 calc(25% - 15px);
			}

			/* 4 per row */
		}

		@media (max-width: 992px) {
			.folderbox {
				flex: 0 0 calc(33.33% - 15px);
			}

			/* 3 per row */
		}

		@media (max-width: 768px) {
			.folderbox {
				flex: 0 0 calc(50% - 15px);
			}

			/* 2 per row */
		}

		@media (max-width: 576px) {
			.folderbox {
				flex: 0 0 100%;
			}

			/* 1 per row on mobile */
		}
	</style>

	<div class="page-wrapper">
		<div class="content">

			<!-- Breadcrumb -->
			<div class="d-flex align-items-center justify-content-between page-breadcrumb mb-3">
				<div class="my-auto mb-2">
					<h2 class="mb-1">Folders</h2>
					<nav>
						<ol class="breadcrumb mb-0">
							<li class="breadcrumb-item"><a href="#"><i class="ti ti-smart-home"></i></a></li>
							<li class="breadcrumb-item">Dashboard</li>
							<li class="breadcrumb-item">Add Document</li>
							<li class="breadcrumb-item">Folder</li>
						</ol>
					</nav>
				</div>
				<div class="rtbtn">
					<a href="#" class="btn btn-primary btn-lg rounded-pill me-2 mb-2 btn-add-folder" id="btnAddFolder">
						<i class="ti ti-plus me-1"></i> Create Folder
					</a>
				</div>
			</div>

			<!-- Directory Path -->
			<div id="uploadDirectoryPath" class="mb-3 p-2 bg-light rounded">
				<div id="folder-no-project" class="text-center py-5" style="display:none;">
					<h4 class="text-muted">Please select a project first</h4>
				</div>
			</div>

			<!-- Folder Container -->
			<div id="folder-container"></div>

			<!-- Loading & Empty -->
			<div id="folder-loading" class="text-center py-4" style="display:none;">
				<div class="spinner-border text-primary"></div>
				<p class="mt-2 text-muted">Loading folders...</p>
			</div>

			<div id="folder-empty" class="text-center py-4" style="display:none;">
				<i class="ti ti-folder-off fs-1 text-muted"></i>
				<p class="mt-2 text-muted">No subfolders found</p>
			</div>

		</div>

		<!-- Footer -->
		<div class="footer mt-4 d-sm-flex align-items-center justify-content-between border-top bg-white p-3">
			<p class="mb-0">2025 &copy; HLFPPT.</p>
			<p>Designed & Developed by <a href="javascript:void(0);" class="text-primary">Duplex services &
					Technology</a></p>
		</div>
	</div>

	<!-- Folder Modal -->
	<%- include('../../modals/addFolder') %>
		<%- include('../../partials/footer') %>

			<script>
				const shareModal = document.getElementById("sharedoc-modal");
				const userInviteSelect = document.getElementById("userInviteSelect");
				const accessLevelSelect = document.getElementById("accessLevelSelect");
				const inviteUserBtn = document.getElementById("inviteUserBtn");
				const usersWithAccessContainer = document.getElementById("usersWithAccessContainer");
				const shareLinkInput = document.getElementById("sharelink");
				const copyLinkBtn = document.getElementById("copyLinkBtn");
				const accessTypeSelect = document.getElementById("accessType");
				const roleTypeSelect = document.getElementById("roleType");

				let currentShareFolderId = null;
				let allUsers = [];

				const folderState = {
					selectedFolders: [],
					currentFolderId: null,
					isLoading: false
				};

				const elements = {
					container: document.getElementById('folder-container'),
					loading: document.getElementById('folder-loading'),
					empty: document.getElementById('folder-empty'),
					path: document.getElementById('uploadDirectoryPath'),
					noProject: document.getElementById('folder-no-project')
				};

				let pendingFolderId = null;
				let editingFolderId = null;

				const setLoadingState = (loading) => {
					elements.loading.style.display = loading ? 'block' : 'none';
					elements.container.style.display = loading ? 'none' : 'flex';
					elements.empty.style.display = 'none';
				};

				const setEmptyState = (isEmpty) => {
					elements.empty.style.display = isEmpty ? 'block' : 'none';
					elements.container.style.display = isEmpty ? 'none' : 'flex';
					elements.loading.style.display = 'none';
				};

				const showNoProject = (show) => {
					elements.noProject.style.display = show ? 'block' : 'none';
				};

				const fetchFolders = async (projectId) => {
					const queryParams = new URLSearchParams();
					if (projectId) queryParams.append('projectId', projectId);

					const response = await fetch(`/api/folders/tree/structure?${queryParams}`, { credentials: 'include' });
					if (!response.ok) throw new Error(`HTTP error! ${response.status}`);
					const data = await response.json();
					if (!data.success) throw new Error(data.message || 'API request failed');
					return data.tree || [];
				};

				const getSubfolders = (folders, targetFolderId) => {
					if (!targetFolderId) return folders;
					const findFolderAndGetChildren = (list, id) => {
						for (const folder of list) {
							if (folder._id === id) return folder.children || [];
							if (folder.children?.length) {
								const res = findFolderAndGetChildren(folder.children, id);
								if (res) return res;
							}
						}
						return [];
					};
					return findFolderAndGetChildren(folders, targetFolderId);
				};

				const loadFolders = async (parentFolderId = null, parentPath = [], projectId = window.selectedProjectId) => {
					try {
						showNoProject(false);

						if (!projectId) {
							elements.container.style.display = 'none';
							setEmptyState(false);
							showNoProject(true);
							return;
						}

						setLoadingState(true);
						const allFolders = await fetchFolders(projectId);
						setLoadingState(false);

						const subfolders = getSubfolders(allFolders, parentFolderId);
						if (!subfolders.length) {
							setEmptyState(true);
							elements.container.innerHTML = "";
							folderState.currentFolderId = parentFolderId;
							folderState.selectedFolders = parentPath;
							updateDirectoryPath();
							return;
						}

						setEmptyState(false);
						elements.container.innerHTML = "";

						subfolders.forEach(folder => {
							const div = document.createElement("div");
							div.className = "folderbox";
							div.dataset.id = folder._id;
							div.innerHTML = `
          <div class="fldricon"><img src="/img/icons/folder.png" alt="Folder"></div>
          <div class="fldrname"><p>${folder.name}</p></div>
          <div class="folder_links">
            <button type="button" class="btn border-0" data-bs-toggle="dropdown"><i class="ti ti-dots"></i></button>
            <ul class="dropdown-menu" data-bs-auto-close="outside">
              <li><a class="dropdown-item" href="/${folder._id}/list"><i class="ti ti-eye"></i> View</a></li>
              <li><a class="dropdown-item rename-folder" href="#"><i class="ti ti-pencil-minus"></i> Rename</a></li>
              <li><a class="dropdown-item share-btn" href="#" data-doc-id="${folder._id}" data-bs-toggle="modal" data-bs-target="#sharedoc-modal"><i class="ti ti-share"></i> Share</a></li>
              <li><a class="dropdown-item download-folder" href="#" data-bs-toggle="modal" data-bs-target="#downloaddoc-modal"><i class="ti ti-download"></i> Download</a></li>
              <li><a class="dropdown-item delete-folder" href="#" data-bs-toggle="modal" data-bs-target="#trashdoc-modal"><i class="ti ti-trash"></i> Move to Trash</a></li>
              <li><a class="dropdown-item archive-folder" href="#" data-bs-toggle="modal" data-bs-target="#archivedoc-modal"><i class="ti ti-archive"></i> Move to Archive</a></li>
            </ul>
          </div>
        `;

							div.addEventListener("dblclick", () => {
								loadFolders(folder._id, [...parentPath, { id: folder._id, name: folder.name }], projectId);
							});

							elements.container.appendChild(div);
						});

						folderState.currentFolderId = parentFolderId;
						folderState.selectedFolders = parentPath;
						updateDirectoryPath();

					} catch (err) {
						setLoadingState(false);
						console.error("Error loading folders:", err);
						showToast("Failed to load folders", "error");
					}
				};

				const updateDirectoryPath = () => {
					const folders = folderState.selectedFolders;
					const pathElements = [];
					pathElements.push(`<a href="javascript:void(0)" class="dir-link" data-id="">Root</a>`);
					folders.forEach(f => pathElements.push(`<a href="javascript:void(0)" class="dir-link" data-id="${f.id}">${f.name}</a>`));
					elements.path.innerHTML = pathElements.join(" / ");

					document.querySelectorAll(".dir-link").forEach(link => {
						link.addEventListener("click", async function () {
							const index = Array.from(this.parentNode.children).indexOf(this);
							let newPath, folderId;
							if (this.dataset.id === "") { newPath = []; folderId = null; }
							else { newPath = folderState.selectedFolders.slice(0, index); newPath.push(folderState.selectedFolders[index]); folderId = this.dataset.id; }
							folderState.selectedFolders = newPath;
							await loadFolders(folderId, newPath, window.selectedProjectId);
						});
					});
				};

				elements.container.addEventListener("click", (e) => {
					const link = e.target.closest("a");
					if (!link) return;
					const folderBox = link.closest(".folderbox");
					if (!folderBox) return;
					const id = folderBox.dataset.id;

					if (link.classList.contains("rename-folder")) {
						editingFolderId = id;
						document.getElementById("folderName").value = folderBox.querySelector(".fldrname p").textContent;
						document.getElementById("folder-modal-title").textContent = "Rename Folder";
						document.getElementById("folderFormSubmit").textContent = "Save";
						new bootstrap.Modal("#folder-modal").show();
					}
					if (link.classList.contains("delete-folder")) pendingFolderId = id;
					if (link.classList.contains("archive-folder")) pendingFolderId = id;
					if (link.classList.contains("download-folder")) pendingFolderId = id;
				});

				document.getElementById("folderForm")?.addEventListener("submit", async (e) => {
					e.preventDefault();
					const name = document.getElementById("folderName").value.trim();
					if (!name) return;

					try {
						const url = editingFolderId ? `/api/folders/${editingFolderId}/rename` : `/api/folders`;
						const method = editingFolderId ? "PATCH" : "POST";
						const body = { name, projectId: window.selectedProjectId || null, parentId: folderState.currentFolderId || null };

						const res = await fetch(url, { method, headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
						const data = await res.json();
						if (!data.success) throw new Error(data.message);

						showToast(editingFolderId ? "Folder renamed" : "Folder created", 'success');
						bootstrap.Modal.getInstance(document.getElementById("folder-modal")).hide();
						editingFolderId = null;
						loadFolders(folderState.currentFolderId, folderState.selectedFolders, window.selectedProjectId);
					} catch (err) {
						console.error(err);
						showToast("Error saving folder", "error");
					}
				});

				document.getElementById("confirm-trash-folder")?.addEventListener("click", async () => {
					if (!pendingFolderId) return;
					try {
						const res = await fetch(`/api/folders/${pendingFolderId}`, { method: "DELETE" });
						const data = await res.json();
						if (!data.success) return showToast(data.message || "Failed to delete folder", "warning");
						showToast(data.message || "Folder deleted successfully", 'success');
						loadFolders(folderState.currentFolderId, folderState.selectedFolders);
					} catch (err) {
						showToast("Failed to delete folder", "error");
					} finally {
						pendingFolderId = null;
						bootstrap.Modal.getInstance(document.getElementById("trashdoc-modal")).hide();
					}
				});

				document.addEventListener("DOMContentLoaded", () => {
					document.querySelector(".btn-add-folder")?.addEventListener("click", () => {
						editingFolderId = null;
						document.getElementById("folderForm").reset();
						document.getElementById("folder-modal-title").textContent = "Add Folder";
						document.getElementById("folderFormSubmit").textContent = "Create";
						new bootstrap.Modal("#folder-modal").show();
					});

					loadFolders();
				});
				async function generateShareLink(folderId, accessType, role) {
					if (!folderId || accessType !== "anyone") return;

					try {
						const res = await fetch(`/api/folders/${folderId}/link`, {
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ access: role === "editor" ? "editor" : "viewer" })
						});

						const data = await res.json();
						if (!res.ok) throw new Error(data.error || "Failed to generate share link");

						// Use the link returned by API directly
						const shareLink = data.link;
						window.currentShareLink = shareLink;
						shareLinkInput.value = shareLink;

					} catch (err) {
						console.error(err);
						shareLinkInput.value = "";
						window.currentShareLink = null;
					}
				}

				// --------------------
				// Folder Share Modal
				// --------------------
				elements.container.addEventListener("click", async (e) => {
					const shareBtn = e.target.closest(".share-btn");
					if (!shareBtn) return;

					currentShareFolderId = shareBtn.dataset.docId;

					// Load API data first
					await loadFolderShares(currentShareFolderId);

					// Update roleType display based on current accessType
					updateAccessInfoText();

					new bootstrap.Modal(shareModal).show();
				});


				function updateAccessInfoText() {
					const infoText = document.getElementById("infoText");

					if (accessTypeSelect.value === "anyone") {
						infoText.textContent = roleTypeSelect.value === "viewer" ?
							"Anyone on the internet with the link can view" :
							"Anyone on the internet with the link can edit";

						// Show roleType dropdown when 'anyone' is selected
						roleTypeSelect.style.display = "inline-block";
					} else {
						infoText.textContent = "Only people with access can view";

						// Hide roleType dropdown when 'restricted' is selected
						roleTypeSelect.style.display = "none";
					}
				}


				// Load shared users and link
				async function loadFolderShares(folderId) {
					try {
						const res = await fetch(`/api/folders/${folderId}`);
						const data = await res.json();

						// Clear previous users
						usersWithAccessContainer.innerHTML = "";

						(data.usersWithAccess || []).forEach(user => {
							const div = document.createElement("div");
							div.className = "user-accssrow d-flex justify-content-between align-items-center mb-2";
							div.innerHTML = `
      <div class="empname_eml">
        <div class="fw-normal fs-18">${user.name}</div>
        <small class="fs-16">${user.email}</small>
      </div>
      <div class="d-flex align-items-center gap-4">
        <div class="form-check form-switch">
          <label>Download Access</label>
          <input class="form-check-input download-access" type="checkbox" ${user.canDownload ? 'checked' : ''} data-user-id="${user.id}">
        </div>
        <select class="form-select form-select-sm border-0" style="width:100px;" data-user-id="${user.id}">
          <option value="edit" ${user.access.includes('edit') ? 'selected' : ''}>Edit</option>
          <option value="view" ${user.access.includes('view') ? 'selected' : ''}>View</option>
        </select>
        <button class="btn btn-sm remvaccessbtn remove-access" data-user-id="${user.id}">Remove</button>
      </div>
    `;
							usersWithAccessContainer.appendChild(div);
						});

						// Set dropdowns and share link based on API data if exists
						if ((data.shareLinks || []).length > 0) {
							const shareData = data.shareLinks[0];
							roleTypeSelect.value = shareData.access === "editor" ? "editor" : "viewer";
							accessTypeSelect.value = shareData.access === "restricted" ? "restricted" : "anyone";

							updateAccessInfoText();

							const shareLink = `${window.location.origin}/folders/${shareData.access}/${folderId}?=${shareData.token}`;
							shareLinkInput.value = shareLink;
							window.currentShareLink = shareLink;
						} else {
							// No existing share link â†’ use defaults
							accessTypeSelect.value = "anyone";
							roleTypeSelect.value = "viewer";
							updateAccessInfoText();
							await generateShareLink(folderId, accessTypeSelect.value, roleTypeSelect.value);
						}

					} catch (err) {
						console.error("Error loading folder shares:", err);
						showToast("Failed to load folder share info", 'error');
					}
				}


				// Invite user
				inviteUserBtn.addEventListener("click", async () => {
					const userId = userInviteSelect.value;
					const access = accessLevelSelect.value;

					if (!currentShareFolderId || !userId) return showToast("Select a user to invite", 'warning');

					let customStart = null;
					let customEnd = null;
					// Determine selected duration
					const durationRadio = document.querySelector('input[name="time"]:checked');
					let duration = durationRadio ? durationRadio.id : "lifetime";
					let expiresAt = null;

					const now = new Date();

					switch (duration) {
						case "oneday":
							expiresAt = new Date(now.getTime() + 1 * 24 * 60 * 60 * 1000);
							break;

						case "oneweek":
							expiresAt = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
							break;

						case "onemonth":
							expiresAt = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
							break;

						case "custom":
							const customRange = document.getElementById("flatpickr-range").value.trim();

							if (!customRange.includes(" to ")) {
								return showToast("Please select a valid custom date range.", 'warning');
							}

							const [startRaw, endRaw] = customRange.split(" to ");

							// ðŸ” Convert DD-MM-YYYY â†’ YYYY-MM-DD
							const [d1, m1, y1] = startRaw.trim().split("-");
							const [d2, m2, y2] = endRaw.trim().split("-");

							const startISO = `${y1}-${m1}-${d1}T00:00:00.000Z`;
							const endISO = `${y2}-${m2}-${d2}T23:59:59.999Z`;

							const startDate = new Date(startISO);
							const endDate = new Date(endISO);

							if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
								return showToast("Invalid date selection. Please reselect range.", 'warning');
							}

							customStart = startDate.toISOString();
							customEnd = endDate.toISOString(); // âœ… Safe now
							expiresAt = customEnd;
							break;

						case "onetime":
							expiresAt = new Date(now.getTime() + 1 * 60 * 60 * 1000);
							break;

						case "lifetime":
						default:
							expiresAt = null;
					}

					try {
						const res = await fetch(`/api/folders/${currentShareFolderId}/share`, {
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({
								userId,
								access,
								shareLink: window.currentShareLink,
								duration,
								expiresAt,
								customStart,  // âœ… NOW SENT
								customEnd     // âœ… NOW SENT
							})
						});

						const data = await res.json();
						if (!res.ok) throw new Error(data.error || "Failed to share folder");

						loadFolderShares(currentShareFolderId);
						userInviteSelect.value = "";
					} catch (err) {
						console.error(err);
						showToast("Failed to invite user", 'error');
					}
				});

				// Remove user access
				usersWithAccessContainer.addEventListener("click", async (e) => {
					if (!e.target.classList.contains("remove-access")) return;

					const userId = e.target.dataset.userId;
					if (!currentShareFolderId || !userId) return;

					if (!confirm("Are you sure you want to remove this user's access?")) return showToast("Removed User from share list", 'success');

					try {
						const res = await fetch(`/api/folders/${currentShareFolderId}/unshare`, {
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ userId })
						});
						const data = await res.json();
						if (!res.ok) throw new Error(data.error || "Failed to remove access");

						loadFolderShares(currentShareFolderId);
					} catch (err) {
						console.error(err);
						showToast("Failed to remove access", 'error');
					}
				});

				usersWithAccessContainer.addEventListener("change", async (e) => {
					if (!e.target.classList.contains("download-access")) return;

					const userId = e.target.dataset.userId;
					const canDownload = e.target.checked;

					if (!currentShareFolderId || !userId) return;

					try {
						const res = await fetch(`/api/folders/${currentShareFolderId}/permissions`, {
							method: "PATCH",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ principalId: userId, canDownload })
						});

						const data = await res.json();
						if (!res.ok) throw new Error(data.error || "Failed to update download access");

						showToast(`Download access ${canDownload ? "enabled" : "disabled"} for user`, 'success');
					} catch (err) {
						console.error(err);
						showToast("Failed to update download access", 'error');
						e.target.checked = !canDownload; // revert checkbox on failure
					}
				});
				usersWithAccessContainer.addEventListener("change", async (e) => {
					if (!e.target.classList.contains("access-level")) return;

					const userId = e.target.dataset.userId;
					const access = e.target.value; // "view" or "edit"

					if (!currentShareFolderId || !userId) return;

					try {
						const res = await fetch(`/api/folders/${currentShareFolderId}/permissions`, {
							method: "PATCH",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify({ principalId: userId, access })
						});

						const data = await res.json();
						if (!res.ok) throw new Error(data.error || "Failed to update access level");

						showToast(`Access level updated to ${access} for user`, 'success');
					} catch (err) {
						console.error(err);
						showToast("Failed to update access level", 'error');
					}
				});


				// Copy share link
				copyLinkBtn.addEventListener("click", () => {
					shareLinkInput.select();
					document.execCommand("copy");
					showToast("Link copied to clipboard", 'success');
				});

				accessTypeSelect.addEventListener("change", async () => {
					updateAccessInfoText();

					if (currentShareFolderId && accessTypeSelect.value === "anyone") {
						// Regenerate share link only when switching back to 'anyone'
						await generateShareLink(currentShareFolderId, accessTypeSelect.value, roleTypeSelect.value);
					} else {
						// Clear share link input when restricted
						shareLinkInput.value = "";
						window.currentShareLink = null;
					}
				});


				roleTypeSelect.addEventListener("change", () => {
					updateAccessInfoText();
					if (currentShareFolderId && accessTypeSelect.value === "anyone") {
						generateShareLink(currentShareFolderId, accessTypeSelect.value, roleTypeSelect.value);
					}
				});

			</script>